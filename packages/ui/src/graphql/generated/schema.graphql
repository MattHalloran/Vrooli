"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

"""Custom description for the date scalar"""
scalar Date

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type Count {
  count: Int
}

type Response {
  code: Int
  message: String!
}

type OpenGraphResponse {
  site: String
  title: String
  description: String
  imageUrl: String
}

type Query {
  readAssets(files: [String!]!): [String]!
  readOpenGraph(url: String!): OpenGraphResponse!
  profile: User!
}

type Mutation {
  writeAssets(files: [Upload!]!): Boolean
  login(email: String, password: String, verificationCode: String): User!
  logout: Boolean
  signUp(username: String!, pronouns: String, email: String!, theme: String!, marketingEmails: Boolean!, password: String!): User!
  updateUser(input: UserInput!, currentPassword: String!, newPassword: String): User!
  deleteUser(id: ID!, password: String): Boolean
  requestPasswordChange(email: String!): Boolean
  resetPassword(id: ID!, code: String!, newPassword: String!): User!
  addEmail(input: EmailInput!): Email!
  updateEmail(input: EmailInput!): Email!
  deleteEmails(ids: [ID!]!): Count!
  addFeedback(input: FeedbackInput!): Boolean!
  addOrganization(input: OrganizationInput!): Organization!
  updateOrganization(input: OrganizationInput!): Organization!
  deleteOrganization(id: ID!): Boolean!
  addResource(input: ResourceInput!): Resource!
  updateResource(input: ResourceInput!): Resource!
  deleteResources(ids: [ID!]!): Count!
  addRoutine(input: RoutineInput!): Routine!
  updateRoutine(input: RoutineInput!): Routine!
  deleteRoutine(id: ID!): Boolean!
  addProject(input: ProjectInput!): Project!
  updateProject(input: ProjectInput!): Project!
  deleteProject(id: ID!): Boolean!
  initValidateWallet(publicAddress: String!, nonceDescription: String): String!
  completeValidateWallet(publicAddress: String!, signedMessage: String!): Boolean!
  removeWallet(id: ID!): Boolean!
}

enum AccountStatus {
  DELETED
  UNLOCKED
  SOFT_LOCKED
  HARD_LOCKED
}

input UserInput {
  id: ID
  username: String
  pronouns: String
  emails: [EmailInput!]
  theme: String
  status: AccountStatus
}

type User {
  id: ID!
  username: String
  pronouns: String!
  emails: [Email!]!
  theme: String!
  emailVerified: Boolean!
  status: AccountStatus!
  roles: [UserRole!]!
}

input EmailInput {
  id: ID
  emailAddress: String!
  receivesDeliveryUpdates: Boolean
  userId: ID
}

type Email {
  id: ID!
  emailAddress: String!
  receivesDeliveryUpdates: Boolean!
  verified: Boolean!
  user: User
}

input FeedbackInput {
  id: ID
  text: String!
  userId: ID
}

input OrganizationInput {
  id: ID
  name: String!
  description: String
  resources: [ResourceInput!]
}

type Organization {
  id: ID!
  name: String!
  description: String
  resources: [Resource!]
  projects: [Project!]
  wallets: [Wallet!]
  starredBy: [User!]
  routines: [Routine!]
}

input ResourceInput {
  id: ID
  name: String!
  description: String
  link: String!
  displayUrl: String
  userId: ID
  organizationId: ID
}

type Resource {
  id: ID!
  name: String!
  description: String
  link: String!
  displayUrl: String
}

input RoutineInput {
  id: ID
}

type Routine {
  id: ID!
}

input ProjectInput {
  id: ID
  name: String!
  description: String
  organizations: [OrganizationInput!]
  users: [UserInput!]
  resources: [ResourceInput!]
}

type Project {
  id: ID!
  name: String!
  description: String
  resources: [Resource!]
  wallets: [Wallet!]
  users: [User!]
  organizations: [Organization!]
  starredBy: [User!]
}

type UserRole {
  user: User!
  role: Role!
}

type Role {
  id: ID!
  title: String!
  description: String
  users: [User!]!
}

type Wallet {
  id: ID!
  publicAddress: String!
  verified: Boolean!
  user: User
  organization: Organization
}
