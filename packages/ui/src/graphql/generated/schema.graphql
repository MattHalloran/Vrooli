"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

"""Custom description for the date scalar"""
scalar Date

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type Count {
  count: Int
}

type Response {
  code: Int
  message: String!
}

type OpenGraphResponse {
  site: String
  title: String
  description: String
  imageUrl: String
}

type Query {
  readAssets(files: [String!]!): [String]!
  readOpenGraph(url: String!): OpenGraphResponse!
  organization(input: FindByIdInput!): Organization
  organizations(input: OrganizationsQueryInput!): [Organization!]!
  organizationsCount: Count!
  project(input: FindByIdInput!): Project
  projects(input: ProjectsQueryInput!): [Project!]!
  projectsCount: Int!
  resource(input: FindByIdInput!): Resource
  resources(input: ResourcesQueryInput!): [Resource!]!
  resourcesCount: Int!
  routine(input: FindByIdInput!): Routine
  routines(input: RoutinesQueryInput!): [Routine!]!
  routinesCount: Int!
  standard(input: FindByIdInput!): Standard
  standards(input: StandardsQueryInput!): [Standard!]!
  standardsCount: Int!
  tag(input: FindByIdInput!): Tag
  tags(input: TagsQueryInput!): [Tag!]!
  tagsCount: Int!
  profile: User!
}

type Mutation {
  writeAssets(files: [Upload!]!): Boolean
  addComment(input: CommentInput!): Email!
  updateComment(input: CommentInput!): Email!
  deleteComment(input: DeleteOneInput!): Boolean!
  reportComment(input: ReportInput!): Boolean!
  voteComment(input: VoteInput!): Boolean!
  addEmail(input: EmailInput!): Email!
  updateEmail(input: EmailInput!): Email!
  deleteEmails(input: DeleteManyInput!): Count!
  addFeedback(input: FeedbackInput!): Boolean!
  addNode(input: NodeInput!): Node!
  updateNode(input: NodeInput!): Node!
  deleteNode(input: DeleteOneInput!): Boolean!
  addOrganization(input: OrganizationInput!): Organization!
  updateOrganization(input: OrganizationInput!): Organization!
  deleteOrganization(input: DeleteOneInput): Boolean!
  reportOrganization(input: ReportInput!): Boolean!
  addProject(input: ProjectInput!): Project!
  updateProject(input: ProjectInput!): Project!
  deleteProject(input: DeleteOneInput!): Boolean!
  reportProject(input: ReportInput!): Boolean!
  addResource(input: ResourceInput!): Resource!
  updateResource(input: ResourceInput!): Resource!
  deleteResources(input: DeleteManyInput!): Count!
  reportResource(input: ReportInput!): Boolean!
  addRoutine(input: RoutineInput!): Routine!
  updateRoutine(input: RoutineInput!): Routine!
  deleteRoutine(input: DeleteOneInput!): Boolean!
  reportRoutine(input: ReportInput!): Boolean!
  addStandard(input: ResourceInput!): Resource!
  updateStandard(input: ResourceInput!): Resource!
  deleteStandards(input: DeleteManyInput!): Count!
  reportStandard(input: ReportInput!): Boolean!
  addTag(input: ResourceInput!): Resource!
  updateTag(input: ResourceInput!): Resource!
  deleteTags(input: DeleteManyInput!): Count!
  reportTag(input: ReportInput!): Boolean!
  voteTag(input: TagVoteInput!): Boolean!
  emailLogIn(input: EmailLogInInput!): User!
  logOut: Boolean
  emailSignUp(input: EmailSignUpInput!): User!
  updateUser(input: UpdateUserInput!): User!
  deleteUser(input: DeleteUserInput!): Boolean
  emailRequestPasswordChange(input: EmailRequestPasswordChangeInput!): Boolean
  emailResetPassword(input: EmailResetPasswordInput!): User!
  reportUser(input: ReportInput!): Boolean!
  exportData: String!
  walletInit(input: WalletInitInput!): String!
  walletComplete(input: WalletCompleteInput!): Boolean!
  removeWallet(input: DeleteOneInput!): Boolean!
}

input FindByIdInput {
  id: ID!
}

input DeleteOneInput {
  id: ID!
}

input DeleteManyInput {
  ids: [ID!]!
}

input ReportInput {
  id: ID!
  reason: String
}

input CommentInput {
  id: ID
  text: String
  objectType: String
  objectId: ID
}

type Comment {
  id: ID!
  text: String
  createdAt: Date!
  updatedAt: Date!
  userId: ID
  user: User
  organizationId: ID
  organization: Organization
  stars: Int
  vote: Int
}

input VoteInput {
  id: ID!
  isUpvote: Boolean!
}

input EmailInput {
  id: ID
  emailAddress: String!
  receivesAccountUpdates: Boolean
  receivesBusinessUpdates: Boolean
  userId: ID
}

type Email {
  id: ID!
  emailAddress: String!
  receivesAccountUpdates: Boolean!
  receivesBusinessUpdates: Boolean!
  verified: Boolean!
  user: User
}

input FeedbackInput {
  text: String!
  userId: ID
}

enum NodeType {
  COMBINE
  DECISION
  END
  LOOP
  ROUTINE_LIST
  REDIRECT
  START
}

union NodeData = NodeCombine | NodeDecision | NodeEnd | NodeLoop | NodeRoutineList | NodeRedirect | NodeStart

input NodeInput {
  id: ID
  routineId: ID
  title: String
  description: String
  type: NodeType
  combineData: NodeCombineInput
  decisionData: NodeDecisionInput
  endData: NodeEndInput
  loopData: NodeLoopInput
  routineListData: NodeRoutineListInput
  redirectData: NodeRedirectInput
  startData: NodeStartInput
}

type Node {
  id: ID!
  routineId: ID!
  title: String!
  description: String
  type: NodeType!
  data: NodeData
  routine: Routine!
}

input NodeCombineInput {
  id: ID
  from: [NodeCombineFromInput!]!
  to: NodeInput
}

type NodeCombine {
  id: ID!
  from: [NodeCombineFrom!]!
  to: Node
}

input NodeCombineFromInput {
  id: ID
  combineId: ID
  fromId: ID
}

type NodeCombineFrom {
  id: ID!
  combineId: ID!
  fromId: ID!
  combine: NodeCombine
  from: Node
}

input NodeDecisionInput {
  id: ID
  decisions: [NodeDecisionItemInput!]!
}

type NodeDecision {
  id: ID!
  decisions: [NodeDecisionItem!]!
}

input NodeDecisionItemInput {
  id: ID
  title: String
  when: [NodeDecisionItemCaseInput]
}

type NodeDecisionItem {
  id: ID!
  title: String!
  when: [NodeDecisionItemCase]!
}

input NodeDecisionItemCaseInput {
  id: ID
  condition: String
}

type NodeDecisionItemCase {
  id: ID!
  condition: String!
}

input NodeEndInput {
  id: ID
}

type NodeEnd {
  id: ID!
}

input NodeLoopInput {
  id: ID
}

type NodeLoop {
  id: ID!
}

input NodeRoutineListInput {
  id: ID
  isOrdered: Boolean
  routines: [NodeRoutineListItemInput!]!
}

type NodeRoutineList {
  id: ID!
  isOrdered: Boolean!
  routines: [NodeRoutineListItem!]!
}

input NodeRoutineListItemInput {
  id: ID
  title: String
  description: String
  isOptional: Boolean
  listId: ID
  routineId: ID
}

type NodeRoutineListItem {
  id: ID!
  title: String!
  description: String
  isOptional: Boolean!
  list: NodeRoutineList
  routine: Routine
}

input NodeRedirectInput {
  id: ID
}

type NodeRedirect {
  id: ID!
}

input NodeStartInput {
  id: ID
}

type NodeStart {
  id: ID!
}

input OrganizationInput {
  id: ID
  name: String!
  description: String
  resources: [ResourceInput!]
}

type Organization {
  id: ID!
  name: String!
  description: String
  resources: [Resource!]
  projects: [Project!]
  wallets: [Wallet!]
  starredBy: [User!]
  routines: [Routine!]
}

input OrganizationsQueryInput {
  first: Int
  skip: Int
}

input ProjectInput {
  id: ID
  name: String!
  description: String
  organizations: [OrganizationInput!]
  users: [UserInput!]
  resources: [ResourceInput!]
}

type Project {
  id: ID!
  name: String!
  description: String
  resources: [Resource!]
  wallets: [Wallet!]
  users: [User!]
  organizations: [Organization!]
  starredBy: [User!]
}

input ProjectsQueryInput {
  first: Int
  skip: Int
}

enum ResourceFor {
  ORGANIZATION
  PROJECT
  ROUTINE_CONTEXTUAL
  ROUTINE_EXTERNAL
  ROUTINE_DONATION
  USER
}

input ResourceInput {
  id: ID
  name: String!
  description: String
  link: String!
  displayUrl: String
  createdFor: ResourceFor!
  forId: ID!
}

type Resource {
  id: ID!
  name: String!
  description: String
  link: String!
  displayUrl: String
}

input ResourcesQueryInput {
  first: Int
  skip: Int
}

type UserRole {
  user: User!
  role: Role!
}

type Role {
  id: ID!
  title: String!
  description: String
  users: [User!]!
}

input RoutineInput {
  id: ID
  version: String
  title: String
  description: String
  instructions: String
  isAutomatable: Boolean
  inputs: [RoutineInputItemInput!]
  outputs: [RoutineOutputItemInput!]
}

type Routine {
  id: ID!
}

input RoutineInputItemInput {
  id: ID
}

type RoutineInputItem {
  id: ID!
}

input RoutineOutputItemInput {
  id: ID
}

type RoutineOutputItem {
  id: ID!
}

input RoutinesQueryInput {
  first: Int
  skip: Int
}

enum StandardType {
  STRING
  NUMBER
  BOOLEAN
  OBJECT
  ARRAY
  FILE
  URL
}

input StandardInput {
  id: ID
  name: String
  description: String
  type: StandardType
  schema: String
  default: String
  isFile: Boolean
  tags: [TagInput!]
}

type Standard {
  id: ID!
  name: String!
  description: String
  type: StandardType!
  schema: String!
  default: String
  isFile: Boolean!
  tags: [Tag!]!
}

input StandardsQueryInput {
  first: Int
  skip: Int
}

input TagInput {
  id: ID
}

type Tag {
  id: ID!
}

input TagsQueryInput {
  first: Int
  skip: Int
}

input TagVoteInput {
  id: ID!
  isUpvote: Boolean!
  objectType: String!
  objectId: ID!
}

enum AccountStatus {
  DELETED
  UNLOCKED
  SOFT_LOCKED
  HARD_LOCKED
}

input UserInput {
  id: ID
  username: String
  pronouns: String
  emails: [EmailInput!]
  theme: String
  status: AccountStatus
}

type User {
  id: ID!
  username: String
  pronouns: String!
  emails: [Email!]!
  theme: String!
  emailVerified: Boolean!
  status: AccountStatus!
  roles: [UserRole!]!
}

input EmailLogInInput {
  email: String
  password: String
  verificationCode: String
}

input EmailSignUpInput {
  username: String!
  pronouns: String
  email: String!
  theme: String!
  marketingEmails: Boolean!
  password: String!
}

input UpdateUserInput {
  data: UserInput!
  currentPassword: String!
  newPassword: String
}

input DeleteUserInput {
  id: ID!
  password: String
}

input EmailRequestPasswordChangeInput {
  email: String!
}

input EmailResetPasswordInput {
  id: ID!
  code: String!
  newPassword: String!
}

type Wallet {
  id: ID!
  publicAddress: String!
  verified: Boolean!
  user: User
  organization: Organization
}

input WalletInitInput {
  publicAddress: String!
  nonceDescription: String
}

input WalletCompleteInput {
  publicAddress: String!
  signedMessage: String!
}
